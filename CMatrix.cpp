/***********************************************************************************

  Module :	CMatrix.cpp

  Description :

  Last Modified $Date: $

  $Revision: $

  Copyright (C) 2005 - File Assistant++ - Titan Demodivision

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

  Contact information
  71M - 71m@orange.net
  Shazz - shazz@titan-whq.info

***********************************************************************************/

//**********************************************************************************
//   Include Files
//**********************************************************************************
#include "CMatrix.h"

//**********************************************************************************
//   Local Macros
//**********************************************************************************

//**********************************************************************************
//   Local Constants
//**********************************************************************************

//**********************************************************************************
//   Static Prototypes
//**********************************************************************************

//**********************************************************************************
//   Global Variables
//**********************************************************************************

//**********************************************************************************
//   Static Variables
//**********************************************************************************

//**********************************************************************************
//   Class Definition
//**********************************************************************************
M44::M44()
{
}

M44::M44( const MATRIX_4X4 & matrix ) : MATRIX_4X4( matrix )
{
}

M44::M44( const MATRIX_4X4 * p_matrix ) : MATRIX_4X4( (float *)p_matrix )
{
}

M44::M44( const M44 & matrix ) : MATRIX_4X4( matrix )
{
}

M44::M44( const M44 * p_matrix ) : MATRIX_4X4( (float *)p_matrix )
{
}

M44::M44( float _11, float _12, float _13, float _14,
		  float _21, float _22, float _23, float _24,
		  float _31, float _32, float _33, float _34,
		  float _41, float _42, float _43, float _44 )
:	MATRIX_4X4( _11, _12, _13, _14,
				_21, _22, _23, _24,
				_31, _32, _33, _34,
				_41, _42, _43, _44 )
{
}

//**********************************************************************************
//
//**********************************************************************************
M44::operator ScePspFMatrix4 * ()
{
	return ( ScePspFMatrix4 * )( &m );
}

M44::operator const ScePspFMatrix4 * () const
{
	return ( ScePspFMatrix4 * )( &m );
}

//*************************************************************************************
//
//*************************************************************************************
V3 M44::GetPos() const
{
	return V3( m[ 3 ][ 0 ], m[ 3 ][ 1 ], m[ 3 ][ 2 ] );
}

void M44::SetPos( const V3 & pos )
{
	m[ 3 ][ 0 ] = pos.x;
	m[ 3 ][ 1 ] = pos.y;
	m[ 3 ][ 2 ] = pos.z;
	m[ 3 ][ 3 ] = 1.f;
}

//*************************************************************************************
//
//*************************************************************************************
V3 M44::GetAt() const
{
	return V3( m[ 2 ][ 0 ], m[ 2 ][ 1 ], m[ 2 ][ 2 ] );
}

void M44::SetAt( const V3 & at )
{
	m[ 2 ][ 0 ] = at.x;
	m[ 2 ][ 1 ] = at.y;
	m[ 2 ][ 2 ] = at.z;
	m[ 2 ][ 3 ] = 0.f;
}

//*************************************************************************************
//
//*************************************************************************************
V3 M44::GetUp() const
{
	return V3( m[ 1 ][ 0 ], m[ 1 ][ 1 ], m[ 1 ][ 2 ] );
}

void M44::SetUp( const V3 & up )
{
	m[ 1 ][ 0 ] = up.x;
	m[ 1 ][ 1 ] = up.y;
	m[ 1 ][ 2 ] = up.z;
	m[ 1 ][ 3 ] = 0.f;
}

//*************************************************************************************
//
//*************************************************************************************
V3 M44::GetRight() const
{
	return V3( m[ 0 ][ 0 ], m[ 0 ][ 1 ], m[ 0 ][ 2 ] );
}

void M44::SetRight( const V3 & right )
{
	m[ 0 ][ 0 ] = right.x;
	m[ 0 ][ 1 ] = right.y;
	m[ 0 ][ 2 ] = right.z;
	m[ 0 ][ 3 ] = 0.f;
}

//*************************************************************************************
//
//*************************************************************************************
M44 & M44::SetIdentity()
{
	m[ 0 ][ 0 ] = 1.f;	m[ 0 ][ 1 ] = 0.f;	m[ 0 ][ 2 ] = 0.f;	m[ 0 ][ 3 ] = 0.f;
	m[ 1 ][ 0 ] = 0.f;	m[ 1 ][ 1 ] = 1.f;	m[ 1 ][ 2 ] = 0.f;	m[ 1 ][ 3 ] = 0.f;
	m[ 2 ][ 0 ] = 0.f;	m[ 2 ][ 1 ] = 0.f;	m[ 2 ][ 2 ] = 1.f;	m[ 2 ][ 3 ] = 0.f;
	m[ 3 ][ 0 ] = 0.f;	m[ 3 ][ 1 ] = 0.f;	m[ 3 ][ 2 ] = 0.f;	m[ 3 ][ 3 ] = 1.f;

	return *this;
}

//*************************************************************************************
//
//*************************************************************************************
M44 & M44::SetTranslation( float x, float y, float z )
{
	m[ 0 ][ 0 ] = 1.f;	m[ 0 ][ 1 ] = 0.f;	m[ 0 ][ 2 ] = 0.f;	m[ 0 ][ 3 ] = 0.f;
	m[ 1 ][ 0 ] = 0.f;	m[ 1 ][ 1 ] = 1.f;	m[ 1 ][ 2 ] = 0.f;	m[ 1 ][ 3 ] = 0.f;
	m[ 2 ][ 0 ] = 0.f;	m[ 2 ][ 1 ] = 0.f;	m[ 2 ][ 2 ] = 1.f;	m[ 2 ][ 3 ] = 0.f;
	m[ 3 ][ 0 ] = x;	m[ 3 ][ 1 ] = y;	m[ 3 ][ 2 ] = z;	m[ 3 ][ 3 ] = 1.f;

	return *this;
}

M44 & M44::SetTranslation( const V3 & v )
{
	m[ 0 ][ 0 ] = 1.f;	m[ 0 ][ 1 ] = 0.f;	m[ 0 ][ 2 ] = 0.f;	m[ 0 ][ 3 ] = 0.f;
	m[ 1 ][ 0 ] = 0.f;	m[ 1 ][ 1 ] = 1.f;	m[ 1 ][ 2 ] = 0.f;	m[ 1 ][ 3 ] = 0.f;
	m[ 2 ][ 0 ] = 0.f;	m[ 2 ][ 1 ] = 0.f;	m[ 2 ][ 2 ] = 1.f;	m[ 2 ][ 3 ] = 0.f;
	m[ 3 ][ 0 ] = v.x;	m[ 3 ][ 1 ] = v.y;	m[ 3 ][ 2 ] = v.z;	m[ 3 ][ 3 ] = 1.f;

	return *this;
}

//*************************************************************************************
//
//*************************************************************************************
M44 & M44::SetScaling( float sx, float sy, float sz )
{
	m[ 0 ][ 0 ] = sx;	m[ 0 ][ 1 ] = 0.f;	m[ 0 ][ 2 ] = 0.f;	m[ 0 ][ 3 ] = 0.f;
	m[ 1 ][ 0 ] = 0.f;	m[ 1 ][ 1 ] = sy;	m[ 1 ][ 2 ] = 0.f;	m[ 1 ][ 3 ] = 0.f;
	m[ 2 ][ 0 ] = 0.f;	m[ 2 ][ 1 ] = 0.f;	m[ 2 ][ 2 ] = sz;	m[ 2 ][ 3 ] = 0.f;
	m[ 3 ][ 0 ] = 0.f;	m[ 3 ][ 1 ] = 0.f;	m[ 3 ][ 2 ] = 0.f;	m[ 3 ][ 3 ] = 1.f;

	return *this;
}

M44 & M44::SetScaling( float s )
{
	m[ 0 ][ 0 ] = s;	m[ 0 ][ 1 ] = 0.f;	m[ 0 ][ 2 ] = 0.f;	m[ 0 ][ 3 ] = 0.f;
	m[ 1 ][ 0 ] = 0.f;	m[ 1 ][ 1 ] = s;	m[ 1 ][ 2 ] = 0.f;	m[ 1 ][ 3 ] = 0.f;
	m[ 2 ][ 0 ] = 0.f;	m[ 2 ][ 1 ] = 0.f;	m[ 2 ][ 2 ] = s;	m[ 2 ][ 3 ] = 0.f;
	m[ 3 ][ 0 ] = 0.f;	m[ 3 ][ 1 ] = 0.f;	m[ 3 ][ 2 ] = 0.f;	m[ 3 ][ 3 ] = 1.f;

	return *this;
}

//*************************************************************************************
//
//*************************************************************************************
M44 & M44::SetRotationAxis( const V3 & axis, float r )
{
	const float	c( cosf( r ) );
	const float	s( sinf( r ) );
	const float	t( 1.f - c );

	// build the rotation matrix
	m[ 0 ][ 0 ] = t * axis.x * axis.x + c;
	m[ 0 ][ 1 ] = t * axis.x * axis.y - s * axis.z;
	m[ 0 ][ 2 ] = t * axis.x * axis.z + s * axis.y;
	m[ 0 ][ 3 ] = 0.f;

	m[ 1 ][ 0 ] = t * axis.x * axis.y + s * axis.z;
	m[ 1 ][ 1 ] = t * axis.y * axis.y + c;
	m[ 1 ][ 2 ] = t * axis.y * axis.z - s * axis.x;
	m[ 1 ][ 3 ] = 0;

	m[ 2 ][ 0 ] = t * axis.x * axis.z - s * axis.y;
	m[ 2 ][ 1 ] = t * axis.y * axis.z + s * axis.x;
	m[ 2 ][ 2 ] = t * axis.z * axis.z + c;
	m[ 2 ][ 3 ] = 0;

	m[ 3 ][ 0 ] = 0.f;
	m[ 3 ][ 1 ] = 0.f;
	m[ 3 ][ 2 ] = 0.f;
	m[ 3 ][ 3 ] = 1.f;

	return *this;
}

//*************************************************************************************
//
//*************************************************************************************
M44 & M44::SetRotationX( float x_rot )
{
	const V3	r( RotateX( gRightVector, x_rot ) );
	const V3	u( RotateX( gUpVector, x_rot ) );
	const V3	a( RotateX( gAtVector, x_rot ) );

	m[ 0 ][ 0 ] = r.x;	m[ 0 ][ 1 ] = r.y;	m[ 0 ][ 2 ] = r.z;	m[ 0 ][ 3 ] = 0.f;
	m[ 1 ][ 0 ] = u.x;	m[ 1 ][ 1 ] = u.y;	m[ 1 ][ 2 ] = u.z;	m[ 1 ][ 3 ] = 0.f;
	m[ 2 ][ 0 ] = a.x;	m[ 2 ][ 1 ] = a.y;	m[ 2 ][ 2 ] = a.z;	m[ 2 ][ 3 ] = 0.f;
	m[ 3 ][ 0 ] = 0.f;	m[ 3 ][ 1 ] = 0.f;	m[ 3 ][ 2 ] = 0.f;	m[ 3 ][ 3 ] = 1.f;

	return *this;
}

//*************************************************************************************
//
//*************************************************************************************
M44 & M44::SetRotationY( float y_rot )
{
	const V3	r( RotateY( gRightVector, y_rot ) );
	const V3	u( RotateY( gUpVector, y_rot ) );
	const V3	a( RotateY( gAtVector, y_rot ) );

	m[ 0 ][ 0 ] = r.x;	m[ 0 ][ 1 ] = r.y;	m[ 0 ][ 2 ] = r.z;	m[ 0 ][ 3 ] = 0.f;
	m[ 1 ][ 0 ] = u.x;	m[ 1 ][ 1 ] = u.y;	m[ 1 ][ 2 ] = u.z;	m[ 1 ][ 3 ] = 0.f;
	m[ 2 ][ 0 ] = a.x;	m[ 2 ][ 1 ] = a.y;	m[ 2 ][ 2 ] = a.z;	m[ 2 ][ 3 ] = 0.f;
	m[ 3 ][ 0 ] = 0.f;	m[ 3 ][ 1 ] = 0.f;	m[ 3 ][ 2 ] = 0.f;	m[ 3 ][ 3 ] = 1.f;

	return *this;
}

//*************************************************************************************
//
//*************************************************************************************
M44 & M44::SetRotationZ( float z_rot )
{
	const V3	r( RotateZ( gRightVector, z_rot ) );
	const V3	u( RotateZ( gUpVector, z_rot ) );
	const V3	a( RotateZ( gAtVector, z_rot ) );

	m[ 0 ][ 0 ] = r.x;	m[ 0 ][ 1 ] = r.y;	m[ 0 ][ 2 ] = r.z;	m[ 0 ][ 3 ] = 0.f;
	m[ 1 ][ 0 ] = u.x;	m[ 1 ][ 1 ] = u.y;	m[ 1 ][ 2 ] = u.z;	m[ 1 ][ 3 ] = 0.f;
	m[ 2 ][ 0 ] = a.x;	m[ 2 ][ 1 ] = a.y;	m[ 2 ][ 2 ] = a.z;	m[ 2 ][ 3 ] = 0.f;
	m[ 3 ][ 0 ] = 0.f;	m[ 3 ][ 1 ] = 0.f;	m[ 3 ][ 2 ] = 0.f;	m[ 3 ][ 3 ] = 1.f;

	return *this;
}

//*************************************************************************************
//
//*************************************************************************************
M44 & M44::Multiply( const M44 & matrix )
{
	M44	final;

	for (u32 r = 0; r < 4; r++)
	{
		for (u32 c = 0; c < 4; c++)
		{
			final.m[ r ][ c ] = m[ r ][ 0 ] * matrix.m[ 0 ][ c ] +
				m[ r ][ 1 ] * matrix.m[ 1 ][ c ] +
				m[ r ][ 2 ] * matrix.m[ 2 ][ c ] +
				m[ r ][ 3 ] * matrix.m[ 3 ][ c ];
		}
	}

	*this = final;

	return *this;
}

//*************************************************************************************
//
//*************************************************************************************
M44 M44::Inverse( float * const p_det ) const
{
	M44	result;

	result.m[0][0] = m[1][1] * m[2][2] - m[1][2] * m[2][1];
	result.m[0][1] = m[0][2] * m[2][1] - m[0][1] * m[2][2];
	result.m[0][2] = m[0][1] * m[1][2] - m[0][2] * m[1][1];
	result.m[0][3] = 0.f;
	result.m[1][0] = m[1][2] * m[2][0] - m[1][0] * m[2][2];
	result.m[1][1] = m[0][0] * m[2][2] - m[0][2] * m[2][0];
	result.m[1][2] = m[0][2] * m[1][0] - m[0][0] * m[1][2];
	result.m[1][3] = 0.f;
	result.m[2][0] = m[1][0] * m[2][1] - m[1][1] * m[2][0];
	result.m[2][1] = m[0][1] * m[2][0] - m[0][0] * m[2][1];
	result.m[2][2] = m[0][0] * m[1][1] - m[0][1] * m[1][0];
	result.m[2][3] = 0.f;
	result.m[3][0] = 0.f;
	result.m[3][1] = 0.f;
	result.m[3][2] = 0.f;
	result.m[3][3] = 1.f;

	const float	fDet( m[0][0] * result.m[0][0] + m[0][1] * result.m[1][0] + m[0][2] * result.m[2][0] );

	if (FABSF( fDet ) > VERY_SMALL)
	{
		const float	fInvDet( 1.0f / fDet);

		for (u32 r = 0; r < 3; r++)
		{
			for (u32 c = 0; c < 3; c++)
			{
				result.m[ r ][ c ] *= fInvDet;
			}
		}
	}

	if (p_det != NULL)
	{
		*p_det = fDet;
	}

	return result;
}

//*************************************************************************************
//
//*************************************************************************************
M44 M44::Transpose() const
{
	M44	transpose;

	for (u32 r = 0; r < 4; r++)
	{
		for (int c = 0; c < 4; c++)
		{
			transpose.m[ r ][ c ] = m[ c ][ r ];
		}
	}

	return transpose;
}

//*************************************************************************************
//
//*************************************************************************************
M44 & M44::Scale( const float xval, const float yval, const float zval )
{
	m[0][0] *= xval;
	m[1][0] *= xval;
	m[2][0] *= xval;

	m[0][1] *= yval;
	m[1][1] *= yval;
	m[2][1] *= yval;

	m[0][2] *= zval;
	m[1][2] *= zval;
	m[2][2] *= zval;

	return *this;
}

M44 & M44::Scale( const float & s )
{
	return Scale( s, s, s );
}

M44 & M44::Scale( const V3 & s )
{
	return Scale( s.x, s.y, s.z );
}

//*************************************************************************************
//
//*************************************************************************************
M44 & M44::NormaliseScale()
{
	SetAt( GetAt().Normal() );
	SetUp( GetUp().Normal() );
	SetRight( GetRight().Normal() );

	return *this;
}

//*************************************************************************************
//
//*************************************************************************************
V3 M44::TransformCoord( const V3 & vector ) const
{
	return V3( m[ 0 ][ 0 ] * vector.x + m[ 0 ][ 1 ] * vector.y + m[ 0 ][ 2 ] * vector.z + m[ 3 ][ 0 ],
			   m[ 1 ][ 0 ] * vector.x + m[ 1 ][ 1 ] * vector.y + m[ 1 ][ 2 ] * vector.z + m[ 3 ][ 1 ],
			   m[ 2 ][ 0 ] * vector.x + m[ 2 ][ 1 ] * vector.y + m[ 2 ][ 2 ] * vector.z + m[ 3 ][ 2 ] );
}

//*************************************************************************************
//
//*************************************************************************************
V3 M44::TransformNormal( const V3 & vector ) const
{
	return V3( m[ 0 ][ 0 ] * vector.x + m[ 0 ][ 1 ] * vector.y + m[ 0 ][ 2 ] * vector.z,
			   m[ 1 ][ 0 ] * vector.x + m[ 1 ][ 1 ] * vector.y + m[ 1 ][ 2 ] * vector.z,
			   m[ 2 ][ 0 ] * vector.x + m[ 2 ][ 1 ] * vector.y + m[ 2 ][ 2 ] * vector.z );
}

//**********************************************************************************
//
//**********************************************************************************
void	M44::Projection( float fovy, float aspect, float near, float far )
{
	SetIdentity();

	float angle = (fovy / 2.0f) * (M_PI/180.0f);
	float cotangent = cosf(angle) / sinf(angle);

	m[0][0] = cotangent / aspect;
	m[1][1] = cotangent;
	m[2][2] = (far + near) / (near - far);
	m[3][2] = 2.0f * (far * near) / (near - far);
	m[2][3] = -1.0f;
	m[3][3] = 0.0f;
}

//*******************************  END OF FILE  ************************************
